# CS-320
Through these efforts, I discovered that making sure software is secure and functional requires more than just developing functional code; it also entails predicting failure spots, verifying inputs, and employing thorough testing to find hidden problems.  I used JUnit testing, concentrating on boundary and negative testing, to make sure my code handled both valid and incorrect inputs.  By using these techniques, I was able to identify problems early and produce more dependable, maintainable code.  Additionally, I realized how important exception management is, and I intend to do better by including stronger error-handling strategies like informative error messages and custom exceptions.

My implementation was greatly influenced by my comprehension of user demands.  I made that the program behaved as intended by converting requirements into test cases and validation criteria, such as restricting phone numbers to precisely ten digits or rejecting null names.  My ability to critically analyze requirements and create functionality that meets actual user expectations has improved as a result of this approach.

I prioritized testability, clarity, and modularity in my software design process.  The system was made scalable and maintainable by using helper methods to keep my code DRY and by using collections like HashMap for effective data management.  In order to create even more robust systems, I intend to investigate integration testing, equivalency partitioning, and test-driven development further as I continue to develop software.  I've learned from these projects that quality assurance is a philosophy that permeates every stage of development rather than existing as a distinct phase.
